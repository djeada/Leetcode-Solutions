## Data Structures

* **`stack`** - Stack data structure for LIFO operations

## Overall Approach

The problem asks us to find node to remove to minimize malware spread.

This solution uses a **Stack** to maintain elements in LIFO order.

The algorithm works by:

1. **Step 1**
   
   ```python
   def minMalwareSpread(self, graph: List[List[int]], initial: List[int]) -> int:
        n = len(graph)
        # Sort so ties naturally go to the smaller index
   ```
2. **Step 2**
   
   ```python
   def build_adjacency_lists() -> List[List[int]]:
            return [
                [j for j, connected in enumerate(row) if connected == 1]
   ```

## Complexity Analysis

* **Time Complexity**: O(n log n)
* **Space Complexity**: O(1)

## Key Insights

* Consider edge cases and boundary conditions
* The algorithm handles the problem constraints efficiently

## Source Code Analysis

```python
from typing import List

class Solution:
    def minMalwareSpread(self, graph: List[List[int]], initial: List[int]) -> int:
        n = len(graph)
        # Sort so ties naturally go to the smaller index
        initially_infected = sorted(initial)

        def build_adjacency_lists() -> List[List[int]]:
            return [
                [j for j, connected in enumerate(row) if connected == 1]
                for row in graph
            ]

        def find_connected_components(adj_lists: List[List[int]]):
            comp_id = [-1] * n
            comp_sizes = []
            current_id = 0

            for node in range(n):
                if comp_id[node] == -1:
                    # start a new component
                    stack = [node]
                    comp_id[node] = current_id
                    size = 0

                    while stack:
                        u = stack.pop()
                        size += 1
                        for v in adj_lists[u]:
                            if comp_id[v] == -1:
                                comp_id[v] = current_id
                                stack.append(v)

                    comp_sizes.append(size)
                    current_id += 1

            return comp_id, comp_sizes

        # 1) Build adjacency lists once
        adj_lists = build_adjacency_lists()

        # 2) Find components and their sizes
        comp_id, comp_sizes = find_connected_components(adj_lists)

        # 3) Count how many initially infected nodes fall into each component
        infected_count_per_comp = [0] * len(comp_sizes)
        for u in initially_infected:
            infected_count_per_comp[comp_id[u]] += 1

        # 4) Of all initially infected nodes that are *the sole* infection
        #    in their component, pick the one whose removal “saves” the largest component.
        best_node = initially_infected[0]
        max_saved = -1

        for u in initially_infected:
            cid = comp_id[u]
            if infected_count_per_comp[cid] == 1:
                # by removing u, we prevent its entire component from ever getting infected
                saved = comp_sizes[cid]
                if saved > max_saved:
                    max_saved = saved
                    best_node = u

        # 5) If no node is the unique infection in its component, we fall back
        #    to removing the smallest-indexed node
        return best_node
```

## Related Problems

* Similar problems involving the same algorithmic techniques
* Problems with related data structures or approaches
